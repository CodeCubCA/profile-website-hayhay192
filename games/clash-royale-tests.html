<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale Game Tests</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .test-section {
            margin-bottom: 30px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
        }
        .test-section h2 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        .test-case {
            background: #f8f9fa;
            margin: 10px 0;
            padding: 15px;
            border-left: 4px solid #007bff;
            border-radius: 4px;
        }
        .test-case.passed {
            border-left-color: #28a745;
            background: #d4edda;
        }
        .test-case.failed {
            border-left-color: #dc3545;
            background: #f8d7da;
        }
        .test-result {
            font-weight: bold;
            margin-top: 10px;
        }
        .passed {
            color: #28a745;
        }
        .failed {
            color: #dc3545;
        }
        .run-tests-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            margin: 20px 0;
        }
        .run-tests-btn:hover {
            background: #0056b3;
        }
        .performance-metrics {
            background: #e9ecef;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
        }
        .code-block {
            background: #f4f4f4;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>Clash Royale Game Comprehensive Test Suite</h1>
        <p>This test suite validates all game mechanics to ensure 100% Clash Royale authenticity.</p>

        <button class="run-tests-btn" onclick="runAllTests()">Run All Tests</button>

        <div id="test-results">
            <!-- Test results will be populated here -->
        </div>
    </div>

    <script>
        // Mock game objects for testing (simplified versions of the actual game classes)
        class MockGameState {
            constructor() {
                this.entities = [];
                this.towers = [];
                this.CANVAS_WIDTH = 450;
                this.CANVAS_HEIGHT = 520; // Game area only
            }

            reset() {
                this.entities = [];
                this.towers = [];
            }

            addEntity(entity) {
                this.entities.push(entity);
            }

            addTower(tower) {
                this.towers.push(tower);
            }
        }

        class MockUnit {
            constructor(x, y, data, owner) {
                this.x = x;
                this.y = y;
                this.data = data;
                this.owner = owner;
                this.health = data.health;
                this.maxHealth = data.health;
                this.isDead = false;
                this.range = data.range * 15; // Current range scaling
                this.target = null;
                this.targetType = data.targetType || 'any';
            }

            getDistance(target) {
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            findTarget() {
                let closestDistance = Infinity;
                let closestTarget = null;

                // Test the current targeting logic
                [...gameState.entities, ...gameState.towers].forEach(entity => {
                    if (entity.owner !== this.owner && !entity.isDead && entity.health > 0) {
                        const distance = this.getDistance(entity);

                        // Current logic - doesn't prioritize princess towers
                        if (distance < closestDistance && distance <= this.range) {
                            closestDistance = distance;
                            closestTarget = entity;
                        }
                    }
                });

                this.target = closestTarget;
                return closestTarget;
            }

            // Improved targeting logic that prioritizes princess towers
            findTargetImproved() {
                let princessTowers = [];
                let kingTowers = [];
                let otherTargets = [];

                [...gameState.entities, ...gameState.towers].forEach(entity => {
                    if (entity.owner !== this.owner && !entity.isDead && entity.health > 0) {
                        const distance = this.getDistance(entity);

                        if (distance <= this.range) {
                            if (entity.type === 'princess') {
                                princessTowers.push({entity, distance});
                            } else if (entity.type === 'king') {
                                kingTowers.push({entity, distance});
                            } else {
                                otherTargets.push({entity, distance});
                            }
                        }
                    }
                });

                // Priority: Princess towers > King tower > Other targets
                let targetList = [];
                if (princessTowers.length > 0) {
                    targetList = princessTowers;
                } else if (kingTowers.length > 0) {
                    targetList = kingTowers;
                } else {
                    targetList = otherTargets;
                }

                // Sort by distance and pick closest
                if (targetList.length > 0) {
                    targetList.sort((a, b) => a.distance - b.distance);
                    this.target = targetList[0].entity;
                    return this.target;
                }

                this.target = null;
                return null;
            }
        }

        class MockTower {
            constructor(x, y, type, owner) {
                this.x = x;
                this.y = y;
                this.type = type; // 'princess' or 'king'
                this.owner = owner;
                this.health = type === 'king' ? 4056 : 3052;
                this.maxHealth = this.health;
                this.isDead = false;
                this.range = 7 * 15; // Current range scaling
                this.isActive = type === 'princess'; // Princess towers start active
            }
        }

        let gameState = new MockGameState();

        // Test Suite Implementation
        class TestSuite {
            constructor() {
                this.tests = [];
                this.results = [];
            }

            addTest(name, testFunction, section = 'General') {
                this.tests.push({
                    name,
                    testFunction,
                    section,
                    passed: false,
                    error: null,
                    executionTime: 0
                });
            }

            async runTests() {
                this.results = [];

                for (let test of this.tests) {
                    gameState.reset();
                    const startTime = performance.now();

                    try {
                        const result = await test.testFunction();
                        test.passed = result === true;
                        test.error = result === true ? null : result;
                    } catch (error) {
                        test.passed = false;
                        test.error = error.message;
                    }

                    test.executionTime = performance.now() - startTime;
                    this.results.push({...test});
                }

                return this.results;
            }

            generateReport() {
                const sections = {};

                this.results.forEach(test => {
                    if (!sections[test.section]) {
                        sections[test.section] = [];
                    }
                    sections[test.section].push(test);
                });

                let html = '';

                Object.keys(sections).forEach(sectionName => {
                    const sectionTests = sections[sectionName];
                    const passedTests = sectionTests.filter(t => t.passed).length;

                    html += `
                        <div class="test-section">
                            <h2>${sectionName} (${passedTests}/${sectionTests.length} passed)</h2>
                    `;

                    sectionTests.forEach(test => {
                        const statusClass = test.passed ? 'passed' : 'failed';
                        const statusText = test.passed ? 'PASSED' : 'FAILED';

                        html += `
                            <div class="test-case ${statusClass}">
                                <h4>${test.name}</h4>
                                <div class="test-result ${statusClass}">${statusText}</div>
                                ${test.error ? `<div style="color: #dc3545; margin-top: 5px;">Error: ${test.error}</div>` : ''}
                                <div style="color: #6c757d; font-size: 12px; margin-top: 5px;">
                                    Execution time: ${test.executionTime.toFixed(2)}ms
                                </div>
                            </div>
                        `;
                    });

                    html += '</div>';
                });

                return html;
            }
        }

        // Initialize test suite
        const testSuite = new TestSuite();

        // TARGETING PRIORITY TESTS
        testSuite.addTest('Princess towers are targeted before king tower', () => {
            // Setup: Player unit with both princess and king towers in range
            const unit = new MockUnit(225, 300, {health: 100, range: 10}, 'player');
            const princessTower = new MockTower(100, 100, 'princess', 'ai');
            const kingTower = new MockTower(225, 50, 'king', 'ai');

            gameState.addTower(kingTower);
            gameState.addTower(princessTower);

            // Test current logic
            unit.findTarget();
            const currentTarget = unit.target;

            // Test improved logic
            unit.findTargetImproved();
            const improvedTarget = unit.target;

            // Current logic should fail this test, improved should pass
            return improvedTarget && improvedTarget.type === 'princess';
        }, 'Targeting Priority');

        testSuite.addTest('King tower is targeted when no princess towers available', () => {
            const unit = new MockUnit(225, 300, {health: 100, range: 10}, 'player');
            const kingTower = new MockTower(225, 50, 'king', 'ai');

            gameState.addTower(kingTower);

            unit.findTargetImproved();

            return unit.target && unit.target.type === 'king';
        }, 'Targeting Priority');

        testSuite.addTest('Closest princess tower is selected when multiple available', () => {
            const unit = new MockUnit(100, 300, {health: 100, range: 15}, 'player');
            const princessTower1 = new MockTower(50, 100, 'princess', 'ai');
            const princessTower2 = new MockTower(200, 100, 'princess', 'ai');

            gameState.addTower(princessTower1);
            gameState.addTower(princessTower2);

            unit.findTargetImproved();

            // Should target the closer princess tower (tower1)
            const distance1 = unit.getDistance(princessTower1);
            const distance2 = unit.getDistance(princessTower2);

            return unit.target === princessTower1 && distance1 < distance2;
        }, 'Targeting Priority');

        // RANGE CALCULATION TESTS
        testSuite.addTest('Range scaling is proportional to map size', () => {
            const unit = new MockUnit(100, 100, {health: 100, range: 5}, 'player');
            const mapWidth = gameState.CANVAS_WIDTH;
            const mapHeight = gameState.CANVAS_HEIGHT;

            // Current scaling: range * 15
            const currentScaling = 15;
            const scaledRange = 5 * currentScaling;

            // Range should be reasonable relative to map size
            const rangeToMapRatio = scaledRange / Math.min(mapWidth, mapHeight);

            // Range should be between 5% and 25% of map size for balance
            return rangeToMapRatio >= 0.05 && rangeToMapRatio <= 0.25;
        }, 'Range Calculations');

        testSuite.addTest('Unit can target enemies within exact range', () => {
            const unit = new MockUnit(100, 100, {health: 100, range: 5}, 'player');
            const enemy = new MockUnit(175, 100, {health: 100, range: 1}, 'ai'); // Exactly at range boundary

            gameState.addEntity(enemy);

            const distance = unit.getDistance(enemy);
            const expectedRange = 5 * 15; // Current scaling

            return Math.abs(distance - expectedRange) < 1; // Within 1 pixel tolerance
        }, 'Range Calculations');

        testSuite.addTest('Unit cannot target enemies outside range', () => {
            const unit = new MockUnit(100, 100, {health: 100, range: 3}, 'player');
            const enemy = new MockUnit(200, 100, {health: 100, range: 1}, 'ai'); // Outside range

            gameState.addEntity(enemy);

            unit.findTargetImproved();

            return unit.target === null;
        }, 'Range Calculations');

        // MOVEMENT MECHANICS TESTS
        testSuite.addTest('Unit moves towards target when out of range', () => {
            const unit = new MockUnit(100, 100, {health: 100, range: 2, speed: 60}, 'player');
            const enemy = new MockUnit(200, 100, {health: 100, range: 1}, 'ai');

            gameState.addEntity(enemy);

            const initialDistance = unit.getDistance(enemy);

            // Simulate movement (basic movement logic)
            const dx = enemy.x - unit.x;
            const dy = enemy.y - unit.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const moveDistance = unit.data.speed * (1/60); // 1 frame at 60fps

            unit.x += (dx / distance) * moveDistance;
            unit.y += (dy / distance) * moveDistance;

            const finalDistance = unit.getDistance(enemy);

            return finalDistance < initialDistance;
        }, 'Movement Mechanics');

        // VISUAL REPRESENTATION TESTS
        testSuite.addTest('Each card type has unique visual properties', () => {
            const cardTypes = ['knight', 'archer', 'fireball', 'cannon'];
            const visualProperties = new Set();

            cardTypes.forEach(type => {
                // Mock visual property based on card type
                let visual = '';
                switch(type) {
                    case 'knight': visual = 'ðŸ›¡ï¸'; break;
                    case 'archer': visual = 'ðŸ¹'; break;
                    case 'fireball': visual = 'ðŸ”¥'; break;
                    case 'cannon': visual = 'ðŸ’£'; break;
                }
                visualProperties.add(visual);
            });

            // Each card should have unique visual
            return visualProperties.size === cardTypes.length;
        }, 'Visual Representation');

        // COMBAT MECHANICS TESTS
        testSuite.addTest('Damage calculation is accurate', () => {
            const attacker = new MockUnit(100, 100, {health: 100, damage: 50, range: 2}, 'player');
            const defender = new MockUnit(130, 100, {health: 100, damage: 30, range: 1}, 'ai');

            const initialHealth = defender.health;

            // Simulate attack
            defender.health -= attacker.data.damage;

            return defender.health === (initialHealth - attacker.data.damage);
        }, 'Combat Mechanics');

        testSuite.addTest('Units die when health reaches zero', () => {
            const unit = new MockUnit(100, 100, {health: 50, damage: 30, range: 1}, 'player');

            // Take fatal damage
            unit.health = 0;
            unit.isDead = true;

            return unit.isDead === true && unit.health === 0;
        }, 'Combat Mechanics');

        // BUILDING PLACEMENT TESTS
        testSuite.addTest('Buildings can only be placed in valid locations', () => {
            const playerSideY = gameState.CANVAS_HEIGHT * 0.6; // Player side
            const validX = gameState.CANVAS_WIDTH / 2;
            const validY = playerSideY + 50;

            // Mock building placement validation
            const isValidPlacement = (x, y) => {
                return y > playerSideY && x >= 50 && x <= gameState.CANVAS_WIDTH - 50;
            };

            return isValidPlacement(validX, validY);
        }, 'Building Placement');

        testSuite.addTest('Range indicator shows correct area', () => {
            const building = new MockUnit(200, 400, {health: 500, range: 6, type: 'building'}, 'player');
            const expectedRange = 6 * 15; // Current scaling

            // Mock range indicator calculation
            const indicatorRadius = building.range;

            return Math.abs(indicatorRadius - expectedRange) < 1;
        }, 'Building Placement');

        // UNIT SPAWNING TESTS
        testSuite.addTest('Units spawn at correct locations', () => {
            const spawnX = 200;
            const spawnY = 400;

            const unit = new MockUnit(spawnX, spawnY, {health: 100, range: 1}, 'player');

            return unit.x === spawnX && unit.y === spawnY;
        }, 'Unit Spawning');

        testSuite.addTest('Multiple units can spawn without overlap conflicts', () => {
            const unit1 = new MockUnit(200, 400, {health: 100, range: 1}, 'player');
            const unit2 = new MockUnit(210, 400, {health: 100, range: 1}, 'player');

            gameState.addEntity(unit1);
            gameState.addEntity(unit2);

            const distance = unit1.getDistance(unit2);

            // Units should have some minimum spacing
            return distance >= 10;
        }, 'Unit Spawning');

        // PERFORMANCE TESTS
        testSuite.addTest('Game can handle 20+ units without performance degradation', () => {
            const startTime = performance.now();

            // Add 25 units
            for (let i = 0; i < 25; i++) {
                const unit = new MockUnit(
                    100 + (i * 10),
                    200 + (i % 5) * 20,
                    {health: 100, range: 2},
                    i % 2 === 0 ? 'player' : 'ai'
                );
                gameState.addEntity(unit);
            }

            // Simulate targeting for all units
            gameState.entities.forEach(unit => {
                unit.findTargetImproved();
            });

            const executionTime = performance.now() - startTime;

            // Should complete in under 10ms for good performance
            return executionTime < 10;
        }, 'Performance');

        // Main test runner
        async function runAllTests() {
            const button = document.querySelector('.run-tests-btn');
            button.disabled = true;
            button.textContent = 'Running Tests...';

            const results = await testSuite.runTests();
            const report = testSuite.generateReport();

            document.getElementById('test-results').innerHTML = report;

            const totalTests = results.length;
            const passedTests = results.filter(t => t.passed).length;
            const totalTime = results.reduce((sum, t) => sum + t.executionTime, 0);

            // Add performance metrics
            const performanceHtml = `
                <div class="performance-metrics">
                    <h3>Performance Metrics</h3>
                    <p><strong>Total Tests:</strong> ${totalTests}</p>
                    <p><strong>Passed:</strong> ${passedTests}</p>
                    <p><strong>Failed:</strong> ${totalTests - passedTests}</p>
                    <p><strong>Success Rate:</strong> ${((passedTests / totalTests) * 100).toFixed(1)}%</p>
                    <p><strong>Total Execution Time:</strong> ${totalTime.toFixed(2)}ms</p>
                    <p><strong>Average Test Time:</strong> ${(totalTime / totalTests).toFixed(2)}ms</p>
                </div>
            `;

            document.getElementById('test-results').innerHTML = performanceHtml + report;

            button.disabled = false;
            button.textContent = 'Run All Tests';
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', () => {
            // Add initial message
            document.getElementById('test-results').innerHTML = `
                <div class="test-section">
                    <h2>Ready to Test</h2>
                    <p>Click "Run All Tests" to execute the comprehensive test suite for Clash Royale game mechanics.</p>
                    <p>This suite will validate targeting priorities, range calculations, movement mechanics, visual representations, combat systems, building placement, and performance.</p>
                </div>
            `;
        });
    </script>
</body>
</html>